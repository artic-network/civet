```python, name="import_dependencies", echo=False
import matplotlib.pyplot as pyplot
import pandas as pd 
import os
import matplotlib.font_manager as font_manager
import matplotlib as mpl
import tabulate
import csv
import numpy as np
import scipy as sp
import warnings
warnings.filterwarnings("ignore")
from dateutil.relativedelta import relativedelta, FR
import data_parsing as dp
import make_tree_figures as tree_viz
import mapping as mapping
import time_functions as time_func
import prep_data as prep_data
```

```python, name="insert_arguments", echo=False, results='raw'
##INSERT_ARGUMENTS
```
```python, name="prepare_arguments", echo=False, results='raw'

name_stem, tree_fields, graphic_dict, label_fields, date_fields = prep_data.prepping_arguments(name_stem, tree_fields, graphic_dict, label_fields, date_fields)
adm2_to_adm1 = prep_data.prepping_adm2_adm1_data(full_metadata_file)
mapping_json_files = [uk_map, channels_map, ni_map]

font_props = font_manager.FontProperties(family=["sans-serif"])
a = matplotlib.font_manager.FontManager()
a.findfont(font_props, fallback_to_default=True)
pyplot.rcParams.update({'figure.max_open_warning': 0})
mpl.rcParams['font.weight']=50
mpl.rcParams['axes.labelweight']=50

inputs = [tree_fields, label_fields, graphic_dict, node_summary, map_sequences, mapping_trait, map_cols]
```

```python, name="header",echo=False, results='raw'
print(f"![]({sequencing_centre_file})")
```

##INSERT_TITLE

##DATE

##AUTHORS

```python,name="description",echo=False,results='tex'
##DESCRIPTION

```



```python, name="parse metadata", echo=False, results='raw'

full_tax_dict, query_dict, tree_to_tip = dp.parse_all_metadata(treedir, filtered_cog_metadata, full_metadata_file, query, label_fields, tree_fields, date_fields, node_summary, adm2_to_adm1)

time_outputs = time_func.summarise_dates(query_dict)
if type(time_outputs) != bool:
    overall_dates, max_overall_date, min_overall_date,  max_string, min_string = time_outputs
    dates_present = True
else:
    dates_present = False
```

```python, name="QC fails", echo=False, results="raw"
if qc_fail != "": 
    fail_dict = dp.investigate_QC_fails(qc_fail)
    if len(fail_dict) > 0:
        print("The following sequences have failed QC:\n")
        for seq, reason in fail_dict.items():
            pretty_name = seq.replace("'","")
            pretty_reason = reason.replace("'","")
            print(" - " + pretty_name, pretty_reason)
```

```python, name="early descriptions", echo=False, results='tex'
number_seqs = len(query_dict)

cog_number = 0
not_in_cog_number = 0
for tax in query_dict.values():
    if tax.in_cog:
        cog_number += 1
    else:
        not_in_cog_number += 1

prep_data.analyse_inputs(inputs)

print("\n")

print(str(number_seqs) + " queries (" + str(cog_number) + " matched to background database).")
print(str(not_in_cog_number) + " additional sequences provided.")

if dates_present:
    print("Time fields provided: " + ",".join(date_fields))
    print("Earliest date: " + min_string)
    print("Latest date: " + max_string)
else:
    print("No time information provided")
```


```python, name="first_table", echo=False, results="tex"
if cog_number != 0 and not_in_cog_number != 0:
    df_cog, df_seqs = dp.make_initial_table(query_dict, tree_fields, label_fields,False)
    print("**Table 1** | Queries found in COG-UK database.\n")
    print(df_cog.to_markdown())
    print("\n")
    print("**Table 2** | Queries matched to closest COG-UK sequence using input sequences\n")
    print(df_seqs.to_markdown())
elif cog_number == 0 and not_in_cog_number != 0:
    df_seqs = dp.make_initial_table(query_dict, tree_fields, label_fields,False)
    print("**Table 1** | Queries matched to closest COG-UK sequence using input sequences\n")
    print(df_seqs.to_markdown())
elif not_in_cog_number == 0 and cog_number != 0:
    df_cog = dp.make_initial_table(query_dict, tree_fields, label_fields,False)
    print("**Table 1** | Queries found in COG-UK database.\n")
    print(df_cog.to_markdown())
```


```python, name="make_trees", echo=False, include=False, figure=False
too_tall_trees, overall_tree_number, colour_dict_dict, overall_df_dict, tree_order = tree_viz.make_all_of_the_trees(treedir, tree_name_stem, full_tax_dict, query_dict, tree_fields, label_fields, graphic_dict)
```
```python, name="make_legend", echo=False, include=False, results='tex'
for trait, colour_dict in colour_dict_dict.items():
    tree_viz.make_legend(colour_dict_dict)
    number_of_options = len(colour_dict)
    if number_of_options > 15:
        print("WARNING: There are more than 15 options to colour by for " + trait + ", which will make it difficult to see the differences between colours. Consider adding the trait to the taxon labels on the tree by using the flag _--label-fields_ when calling CIVET.")
```
```python, name="time_plot", echo=False, results='raw', include=False
if dates_present:
    count = 0
    tree_to_time_series = {}
    for tree in tree_order:
        count += 1
        lookup = f"{tree_name_stem}_{tree}"
        tips = tree_to_tip[lookup]
        if len(tips) > 1:
            time_func.plot_time_series(tips, query_dict, max_overall_date, min_overall_date, date_fields, label_fields)
            tree_to_time_series[lookup] = count
```

```python, name="show_trees", echo=False, results='raw'
for i in range(1,overall_tree_number+1):
    tree_name = "Tree " + str(i)
    lookup = f"{tree_name_stem}_{i}"
    print(f"> **Tree {i}** | ")
    if len(tree_to_tip[lookup]) == 1:
        print(f"1 sequence of interest")
    else:
        print(f"{len(tree_to_tip[lookup])} sequences of interest")
    print("   ")

    print(f"![]({figdir}/{name_stem}_make_trees_{(i*2)-1}.png)")
    print(f"![]({figdir}/{name_stem}_make_trees_{i*2}.png)")

    print(f'<img src="{figdir}/{name_stem}_make_legend_1.png" alt="drawing" style="width:100%;"/>')
    print("\n")

    if dates_present and lookup in tree_to_time_series.keys():
        print("![](" + figdir + "/" + name_stem + "_time_plot_" + str(tree_to_time_series[lookup]) + ".png)")

    print(f"![]({figdir}/genome_graph_{lookup}.png)")

if too_tall_trees != []:
    for tree in too_tall_trees:
        print("Tree" + str(tree) + " is too large to be rendered here.")
```

```python, name="tree_background", echo=False, include=False,  results='raw'
if add_bars != "":
    print("""### Tree background\n\nThe following plots describe the data in the collapsed nodes in more detail.\nIf more than one country was present, the bar chart describes the number of sequences present in each country. \nWhere there were 10 countries or more, the largest 10 have been taken. \nIf a UK sequence is present in the collapsed node, it is always shown in the plot.\n\n""")
    bar_count = tree_viz.describe_tree_background(full_tax_dict, tree_name_stem, treedir)

    for i in range(bar_count):
        print(f"![]({figdir}/{name_stem}_tree_background_{i+1}.png)")

```

```python, name="map_sequences", echo=False, results='raw', include=False
if map_sequences != "False":
    print("## Plotting sequences")
    if map_cols == "adm2":
        adm2_in_map, adm2_percentages = mapping.map_adm2(query_dict, clean_locs_file, mapping_json_files)
    else:
        adm2_in_map, adm2_percentages = mapping.map_sequences_using_coordinates(query, mapping_json_files, urban_centres, pc_file, mapping_trait, map_cols, input_crs)

    print("There are sequences from " + str(len(adm2_in_map)) + " admin2 regions")

    print("This is divided into:")
    for adm2, percentage in adm2_percentages.items():
        print(str(percentage) + "% (" + str(adm2_in_map[adm2]) + ") in " + adm2)

    if mapping_trait != "False":
        print("This is shown in the map below, and is coloured by " + mapping_trait + " and urban centres are shown in the darker grey")
    else:
        print("This is shown in the map below, with urban centres shown in the darker grey")
```
```python, name="show_map", echo=False, results='raw'
if map_sequences != "False":
    print("![](" + figdir + "/" + name_stem + "_map_sequences_1.png)")
```

```python, name='Regional-scale', echo=False, results='raw'
if local_lineages != '':
    print("## Regional-scale background UK lineage mapping")
    print("These figures show the background diversity of lineages in the local area to aid with identifying uncommon lineages.")
    centralLoc = [ t for t in local_lin_tables.split(';') if "_central_" in t]
    centralName = centralLoc[0].split('/')[-1].split("_")[0]
    linmapList=[f'./{"/".join(p.split("/")[-2:])}' for p in local_lin_maps.split(';')]
    tableList=[t for t in local_lin_tables.split(';') if "_central_" not in t]

    print(f'Based on the sample density for submitted sequences with adm2 metadata, **{centralName}** was determined to be the focal NHS Health-board.')
    print('\n')
    print(f'The below figure visualises the relative proportion of assigned UK-Lineages for samples sampled in **{centralName}** for the defined time-frame.')
    print ("![]("+linmapList[0]+")")
    print('\n')
    print(f'The below figure visualises the relative proportions of assigned UK-Lineages for samples collected in the whole region for the defined time-frame. Plot-size demonstrates relative numbers of sequences across given NHS healthboards.')
    print ("![]("+linmapList[2]+")")
    print('\n')
    #print(f'The below figure visualises the relative proportion of assigned UK-Lineages for samples collected and sequenced within neighbouring healthboard regions for the defined time-frame.')
    #print ("![]("+linmapList[1]+")")
    #print('\n')
    print(f'Tabulated lineage data for the **central** health-board region:')
    with open(centralLoc[0]) as file:
        contents = file.read()
        print (contents)
    print(f'Tabulated lineage data for the **neighbouring** health-board regions:')

    for each in tableList:
        with open(each) as file:
            contents = file.read()
            print (contents)
```

## Appendix

This report summarises the information provided by whole genome sequencing of SARS-COV-2 generated by the COG consortium. 
It is intended to provide an additional layer of analysis for infection control efforts, and to aid in the investigation of outbreak clusters.

For each query sequence, CIVET either finds them in the COG database, or matches them as closely as possible to a sequence in the COG database, and puts them into a UK lineage.

Key points for interpreting this information:

 - This type of analysis is not able to infer direct transmission between two samples. Even identical sequences may be unrelated as SARS-COV2 is relatively slow evolving for an RNA virus. Previous analysis has shown that samples taken over 100 days apart can be identical. 
 - UK lineage and UK phylotype designations are not yet stable, so they can change with each build of the COG-UK phylogeny.
 - If sequences have different global or UK lineage designations, within the same analysis/report, we can rule out close epidemiological linkage.
 - If sequences have different phylotypes, within the same analysis/report, itâ€™s very unlikely that they are direct transmissions. 
 - If sequences share the same lineage and the same phylotype, within the same analysis/report, transmission cannot be ruled out and also cannot be confirmed.


The figure below shows the distribution of time differences that two sequences can be sampled and still be identical. 
It is to illustrate that identical sequences does not confirm linked cases.

```python, name="Identity figure", results='raw', echo=False, fig=True, caption="Distribution of time between identical sequences"
print(f"![]({figdir}/polytomies.png)")
```


### Definitions

*Phylotype* 

Each lineage phylogeny is labelled with phylotypes that describe shared mutations in the tree. If two sequences have the same phylotype it means the share mutations. They may also have additional, unique mutations. So having the same phylotype doesn't mean the seqeunces are identical. If sequences have different phylotypes however it means they are present on distinct parts of the phylogenetic tree.

*UK lineage* 

UK lineages are an approximation to distinct introductions of SARS-CoV-2 to the UK based on the phylogenetic tree.

*Global lineage* 

Assigned using the pangolin software, these are phylogenetic lineages. More information can be found at https://github.com/hCoV-2019/lineages

### Software versions

This report was made using:

```python, name='software versions', echo=False, results='raw'

import platform


print("Python " + platform.python_version())

print("Matplotlib version " + matplotlib.__version__)
print("Pandas version " + pd.__version__)
print("Tabulate version " + tabulate.__version__)
print("CSV version " + csv.__version__)
print("Numpy version " + np.__version__)
print("Scipy version " + sp.__version__)
print("No version number for Baltic")

print("COG data is now submitted every day, so the background data was updated yesterday")

print("CIVET version is 0.1")
```

## Acknowledgements

This report was generated by CIVET.

The background data from the UK was generated by the COG consortium (https://www.cogconsortium.uk/), a national, multi-centre consortium for the sequencing and analysis of SARS-CoV-2 genomes for Public Health.

We also use some background data from GISAID (https://www.gisaid.org/) in the phylogenies. We thank everyone involved in the global sequencing effort for making their data available. 

Tree data was visualised using baltic (https://github.com/evogytis/baltic)

Mapping data was downloaded from the Global Administrative Database (https://gadm.org/) and Natural Earth (https://www.naturalearthdata.com/)

```python, name="footer", echo=False, results='raw'
print("![](" + figdir + "/footer.png)")
```
